<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ubuntu on æµ®ç”Ÿæ—¥è®°</title>
    <link>https://shadow-diary.fun/tags/ubuntu/</link>
    <description>Recent content in Ubuntu on æµ®ç”Ÿæ—¥è®°</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Copy, _right?_ :thinking_face:</copyright>
    <lastBuildDate>Sun, 17 Dec 2023 00:03:59 +0800</lastBuildDate><atom:link href="https://shadow-diary.fun/tags/ubuntu/feed.xml" rel="self" type="application/rss+xml" />
    <item>
<title>ä»€ä¹ˆæ˜¯ROS(ROSå’ŒUbuntuçš„åŒºåˆ«)</title>
<link>https://shadow-diary.fun/posts/2023/common/ros-ubuntu/</link>
<pubDate>Sun, 17 Dec 2023 00:03:59 +0800</pubDate>
      
      <guid>https://shadow-diary.fun/posts/2023/common/ros-ubuntu/</guid>
<description>&lt;h2 class=&#34;relative group&#34;&gt;å®˜ç½‘ 
    &lt;div id=&#34;å®˜ç½‘&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
    
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e5%ae%98%e7%bd%91&#34; aria-label=&#34;Anchor&#34;&gt;#&lt;/a&gt;
    &lt;/span&gt;        
    
&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;The Robot Operating System (ROS) is a set of software libraries and tools that help you build robot applications. From drivers to state-of-the-art algorithms, and with powerful developer tools, ROS has what you need for your next robotics project. And it&amp;rsquo;s all open source.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 class=&#34;relative group&#34;&gt;Wiki 
    &lt;div id=&#34;wiki&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
    
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#wiki&#34; aria-label=&#34;Anchor&#34;&gt;#&lt;/a&gt;
    &lt;/span&gt;        
    
&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Robot_Operating_System&#34;   target=&#34;_blank&#34;&gt;
    Robot Operating System - Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Robot Operating System (ROS or ros) is an open-source robotics middleware suite. Although ROS is not an operating system (OS) but a set of software frameworks for robot software development, it provides services designed for a heterogeneous computer cluster such as hardware abstraction, low-level device control, implementation of commonly used functionality, message-passing between processes, and package management. Running sets of ROS-based processes are represented in a graph architecture where processing takes place in nodes that may receive, post, and multiplex sensor data, control, state, planning, actuator, and other messages. Despite the importance of reactivity and low latency in robot control, ROS is not a real-time operating system (RTOS). However, it is possible to integrate ROS with real-time code.The lack of support for real-time systems has been addressed in the creation of ROS 2, a major revision of the ROS API which will take advantage of modern libraries and technologies for core ROS functions and add support for real-time code and embedded system hardware.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 class=&#34;relative group&#34;&gt;åšå®¢ 
    &lt;div id=&#34;åšå®¢&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
    
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e5%8d%9a%e5%ae%a2&#34; aria-label=&#34;Anchor&#34;&gt;#&lt;/a&gt;
    &lt;/span&gt;        
    
&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Ubuntuæ˜¯ä¸€ä¸ªä»¥æ¡Œé¢åº”ç”¨ä¸ºä¸»çš„Linuxæ“ä½œç³»ç»Ÿï¼Œè€Œraspbianæ˜¯é’ˆå¯¹ Raspberry Pi ä¸“é—¨ä¼˜åŒ–ã€åŸºäº Debian çš„ Raspbian OSã€‚&lt;/p&gt;
&lt;p&gt;ROSè¯´æ˜¯å«æœºå™¨äººæ“ä½œç³»ç»Ÿï¼Œå…¶å®å¹¶ä¸æ˜¯åƒUbuntué‚£æ ·å®Œæ•´çš„ç³»ç»Ÿï¼Œå¯ä»¥ç†è§£æˆROSä¸€ä¸ªä¸­é—´ä»¶æˆ–è€…ä¸€ä¸ªåº“ï¼Œå®ƒéœ€è¦è·‘åœ¨Ubuntuç³»ç»Ÿä¸Šï¼Œæˆ–è€…raspbianç³»ç»Ÿä¸Šã€‚&lt;/p&gt;
&lt;p&gt;æ ‘è“æ´¾æ˜¯ç¡¬ä»¶ï¼Œæ˜¯æ“ä½œç³»ç»Ÿ Ubuntuæˆ–è€…raspbiançš„è½½ä½“ï¼Œå®‰è£…äº†ROSçš„Ubuntuç³»ç»Ÿæ‰èƒ½ä½¿ç”¨ROSä¸­çš„å·¥å…·ï¼Œæ¡†æ¶ç­‰ã€‚&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 class=&#34;relative group&#34;&gt;è‡ªå®šä¹‰æ¶ˆæ¯ 
    &lt;div id=&#34;è‡ªå®šä¹‰æ¶ˆæ¯&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
    
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e8%87%aa%e5%ae%9a%e4%b9%89%e6%b6%88%e6%81%af&#34; aria-label=&#34;Anchor&#34;&gt;#&lt;/a&gt;
    &lt;/span&gt;        
    
&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;catkin_create_pkg custom_message roscpp std_msgs geometry_msgs message_generation
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ä¸ä¹‹å‰ä¸åŒçš„æ˜¯ï¼Œéœ€è¦åœ¨packages.xmlä¸­æ·»åŠ å¦‚ä¸‹å‰ä¸¤è¡Œä¿¡æ¯ï¼ˆæ³¨æ„ï¼Œä¸æ˜¯ç¬¬ä¸‰è¡Œï¼Œé‚£ç§å†™æ³•å·²ç»æ¶ˆå¤±ï¼‰ã€‚&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;build_depend&amp;gt;message_generation&amp;lt;/build_depend&amp;gt;
&amp;lt;exec_depend&amp;gt;message_generation&amp;lt;/exec_depend&amp;gt;
&amp;lt;!-- &amp;lt;exec_depend&amp;gt;message_runtime&amp;lt;/exec_depend&amp;gt; --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CMakeLists.txtå¦‚ä¸‹ï¼š&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cmake_minimum_required(VERSION 3.0.2)
project(custom_message)

find_package(catkin REQUIRED COMPONENTS
  geometry_msgs
  message_generation
  roscpp
  std_msgs
)

# æ–°å¢
add_message_files(
  FILES
  Person.msg
)

# æ–°å¢
generate_messages(
  DEPENDENCIES
  std_msgs
)

# æ–°å¢
catkin_package(
  CATKIN_DEPENDS geometry_msgs message_generation roscpp std_msgs
)

include_directories(
  ${catkin_INCLUDE_DIRS}
)

add_executable(talker1 src/talker1.cpp)
target_link_libraries(talker1 ${catkin_LIBRARIES})

add_executable(listener1 src/listener1.cpp)
target_link_libraries(listener1 ${catkin_LIBRARIES})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;talkerä»£ç ï¼ˆæ³¨æ„è‡ªå®šä¹‰æ¶ˆæ¯å¤´æ–‡ä»¶çš„å¼•å…¥æ–¹æ³•æ˜¯ï¼šåŠŸèƒ½åŒ…å + æ¶ˆæ¯åï¼Œä½¿ç”¨æ—¶éƒ½éœ€è¦æŒ‡å‡ºå‘½åç©ºé—´ä¸ºåŠŸèƒ½åŒ…çš„åç§°ï¼‰ï¼š&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;sstream&amp;gt;
#include &amp;#34;ros/ros.h&amp;#34;
#include &amp;#34;custom_message/Person.h&amp;#34;
int main(int argc, char **argv)
{
    // ROSèŠ‚ç‚¹åˆå§‹åŒ–
    ros::init(argc, argv, &amp;#34;talker1&amp;#34;);
    // åˆ›å»ºèŠ‚ç‚¹å¥æŸ„
    ros::NodeHandle n(&amp;#34;hello&amp;#34;);
    // åˆ›å»ºä¸€ä¸ªPublisherï¼Œå‘å¸ƒåä¸ºchatterçš„topicï¼Œæ¶ˆæ¯ç±»å‹ä¸ºcustom_messages::Person
    ros::Publisher chatter_pub = n.advertise&amp;lt;custom_message::Person&amp;gt;(&amp;#34;custom_msg&amp;#34;, 1000);
    // è®¾ç½®å¾ªç¯çš„é¢‘ç‡
    ros::Rate loop_rate(10);
    int count = 0;
    while (ros::ok())
    {
        // åˆå§‹åŒ–std_msgs::Stringç±»å‹çš„æ¶ˆæ¯
        custom_message::Person msg;
        msg.name = &amp;#34;Lucas Tan&amp;#34;;
        msg.sex = custom_message::Person::unknown;
        // å‘å¸ƒæ¶ˆæ¯
        ROS_INFO(&amp;#34;%s&amp;#34;, msg.name.c_str());
        chatter_pub.publish(msg);
        // å¾ªç¯ç­‰å¾…å›è°ƒå‡½æ•°
        ros::spinOnce();
        // æŒ‰ç…§å¾ªç¯é¢‘ç‡å»¶æ—¶
        loop_rate.sleep();
        ++count;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;listenerä»£ç ï¼š&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;#34;ros/ros.h&amp;#34;
#include &amp;#34;custom_message/Person.h&amp;#34;
// æ¥æ”¶åˆ°è®¢é˜…çš„æ¶ˆæ¯åï¼Œä¼šè¿›å…¥æ¶ˆæ¯å›è°ƒå‡½æ•°
void chatterCallback(const custom_message::Person::ConstPtr&amp;amp; msg)
{
    // å°†æ¥æ”¶åˆ°çš„æ¶ˆæ¯æ‰“å°å‡ºæ¥
    ROS_INFO(&amp;#34;I heard: [%s]&amp;#34;, msg-&amp;gt;name.c_str());
}
int main(int argc, char **argv)
{
    // åˆå§‹åŒ–ROSèŠ‚ç‚¹
    ros::init(argc, argv, &amp;#34;listener1&amp;#34;);
    // åˆ›å»ºèŠ‚ç‚¹å¥æŸ„
    ros::NodeHandle n(&amp;#34;hello&amp;#34;);
    // åˆ›å»ºä¸€ä¸ªSubscriberï¼Œè®¢é˜…åä¸ºchatterçš„è¯é¢˜ï¼Œæ³¨å†Œå›è°ƒå‡½æ•°chatterCallback
    ros::Subscriber sub = n.subscribe(&amp;#34;custom_msg&amp;#34;, 1000, chatterCallback);
    // å¾ªç¯ç­‰å¾…å›è°ƒå‡½æ•°
    ros::spin();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;æœ€ç»ˆæ•ˆæœï¼š&lt;/p&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        srcset=&#34;
        /posts/2023/common/ros-ubuntu/Untitled_hu539c80d9edf717c7f87a908fc5924c77_38008_330x0_resize_box_3.png 330w,
        /posts/2023/common/ros-ubuntu/Untitled_hu539c80d9edf717c7f87a908fc5924c77_38008_660x0_resize_box_3.png 660w,
        /posts/2023/common/ros-ubuntu/Untitled_hu539c80d9edf717c7f87a908fc5924c77_38008_1024x0_resize_box_3.png 1024w,
        /posts/2023/common/ros-ubuntu/Untitled_hu539c80d9edf717c7f87a908fc5924c77_38008_1320x0_resize_box_3.png 2x&#34;
        src=&#34;https://shadow-diary.fun/posts/2023/common/ros-ubuntu/Untitled_hu539c80d9edf717c7f87a908fc5924c77_38008_660x0_resize_box_3.png&#34;
        alt=&#34;Alt text&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;h1 class=&#34;relative group&#34;&gt;std_msgs 
    &lt;div id=&#34;std_msgs&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
    
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#std_msgs&#34; aria-label=&#34;Anchor&#34;&gt;#&lt;/a&gt;
    &lt;/span&gt;        
    
&lt;/h1&gt;
&lt;p&gt;é€šè¿‡rosmsgå‘½ä»¤å¯ä»¥æ–¹ä¾¿åœ°æŸ¥çœ‹æœ‰å“ªäº›msgåŠŸèƒ½åŒ…ä»¥åŠmsgçš„ç»“æ„ã€‚&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;root@f90027cc500f:~# rosmsg -h
rosmsg is a command-line tool for displaying information about ROS Message types.

Commands:
	rosmsg show	Show message description
	rosmsg info	Alias for rosmsg show
	rosmsg list	List all messages
	rosmsg md5	Display message md5sum
	rosmsg package	List messages in a package
	rosmsg packages	List packages that contain messages

Type rosmsg &amp;lt;command&amp;gt; -h for more detailed usage
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;æ¯”å¦‚çœ‹Imageçš„ç»“æ„ï¼ˆä¸ç”¨åˆ°å¤„æ‰¾åŒ…çš„ä½ç½®è¿›å»çœ‹ï¼Œæˆ‘æ˜¯ğŸ¤¡ï¼‰&lt;/p&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        srcset=&#34;
        /posts/2023/common/ros-ubuntu/Untitled-2_hu539c80d9edf717c7f87a908fc5924c77_19066_330x0_resize_box_3.png 330w,
        /posts/2023/common/ros-ubuntu/Untitled-2_hu539c80d9edf717c7f87a908fc5924c77_19066_660x0_resize_box_3.png 660w,
        /posts/2023/common/ros-ubuntu/Untitled-2_hu539c80d9edf717c7f87a908fc5924c77_19066_1024x0_resize_box_3.png 1024w,
        /posts/2023/common/ros-ubuntu/Untitled-2_hu539c80d9edf717c7f87a908fc5924c77_19066_1320x0_resize_box_3.png 2x&#34;
        src=&#34;https://shadow-diary.fun/posts/2023/common/ros-ubuntu/Untitled-2_hu539c80d9edf717c7f87a908fc5924c77_19066_660x0_resize_box_3.png&#34;
        alt=&#34;Alt text&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;h1 class=&#34;relative group&#34;&gt;ros::spin() å’Œ ros::spinOnce()åŒºåˆ« 
    &lt;div id=&#34;rosspin-å’Œ-rosspinonceåŒºåˆ«&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
    
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#rosspin-%e5%92%8c-rosspinonce%e5%8c%ba%e5%88%ab&#34; aria-label=&#34;Anchor&#34;&gt;#&lt;/a&gt;
    &lt;/span&gt;        
    
&lt;/h1&gt;
&lt;p&gt;é¦–å…ˆæ˜ç¡®ï¼Œè¿™ä¸¤ä¸ªéƒ½æ˜¯**ROSæ¶ˆæ¯å›è°ƒå¤„ç†å‡½æ•°ã€‚**ä¹Ÿå°±æ˜¯è¯´æ˜¯ç”¨äºè®¢é˜…è€…çš„ã€‚&lt;/p&gt;
&lt;h2 class=&#34;relative group&#34;&gt;åŒºåˆ« 
    &lt;div id=&#34;åŒºåˆ«&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
    
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e5%8c%ba%e5%88%ab&#34; aria-label=&#34;Anchor&#34;&gt;#&lt;/a&gt;
    &lt;/span&gt;        
    
&lt;/h2&gt;
&lt;p&gt;ros::**spin()**åœ¨è°ƒç”¨åä¸ä¼šå†è¿”å›ï¼Œä¹Ÿå°±æ˜¯ä½ çš„ä¸»ç¨‹åºåˆ°è¿™å„¿å°±ä¸å¾€ä¸‹æ‰§è¡Œäº†ï¼Œè€Œæ˜¯è¿›è¡Œä¸‹ä¸€æ¬¡å›è°ƒã€‚ï¼ˆros::spin()å‡½æ•°ä¸€èˆ¬ä¸ä¼šå‡ºç°åœ¨å¾ªç¯ä¸­ï¼Œå› ä¸ºç¨‹åºæ‰§è¡Œåˆ°spin()åå°±ä¸è°ƒç”¨å…¶ä»–è¯­å¥äº†ï¼Œä¹Ÿå°±æ˜¯è¯´è¯¥å¾ªç¯æ²¡æœ‰ä»»ä½•æ„ä¹‰ï¼‰ã€‚&lt;/p&gt;
&lt;p&gt;è€ŒÂ **ros::spinOnce()**åè€…åœ¨è°ƒç”¨åè¿˜å¯ä»¥ç»§ç»­æ‰§è¡Œä¹‹åçš„ç¨‹åºï¼Œä½†å¾€å¾€éœ€è¦è€ƒè™‘è°ƒç”¨æ¶ˆæ¯çš„æ—¶æœºï¼Œè°ƒç”¨é¢‘ç‡ï¼Œä»¥åŠæ¶ˆæ¯æ± çš„å¤§å°ã€‚&lt;/p&gt;
&lt;p&gt;é€šå¸¸å’Œå¾ªç¯ä»¥åŠloop_rate.sleep()ä¸€èµ·ä½¿ç”¨ã€‚&lt;/p&gt;
&lt;h2 class=&#34;relative group&#34;&gt;ä»£ç å¯¹æ¯”åŒºåˆ« 
    &lt;div id=&#34;ä»£ç å¯¹æ¯”åŒºåˆ«&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
    
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e4%bb%a3%e7%a0%81%e5%af%b9%e6%af%94%e5%8c%ba%e5%88%ab&#34; aria-label=&#34;Anchor&#34;&gt;#&lt;/a&gt;
    &lt;/span&gt;        
    
&lt;/h2&gt;
&lt;h3 class=&#34;relative group&#34;&gt;talker 
    &lt;div id=&#34;talker&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
    
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#talker&#34; aria-label=&#34;Anchor&#34;&gt;#&lt;/a&gt;
    &lt;/span&gt;        
    
&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;#34;ros/ros.h&amp;#34;
#include &amp;#34;std_msgs/String.h&amp;#34;
// Why we need sstream? Because we need this to split a sentence to words.
#include &amp;lt;sstream&amp;gt;

int main(int argc, char **argv)
{
    // init, can not have namespace
    ros::init(argc, argv, &amp;#34;talker&amp;#34;);
    // start, this is a c11 initialization mode
    ros::NodeHandle n(&amp;#34;namespace&amp;#34;);
    // Define publisher&amp;#39;s topic name and msg type.
    ros::Publisher chatter_pub = n.advertise&amp;lt;std_msgs::String&amp;gt;(&amp;#34;chatter&amp;#34;, 1000);
    // set loop rate(per sec)
    ros::Rate loop_rate(10);
    int count = 0;
    // ros::ok()åœ¨ä»¥ä¸‹å‡ ç§æƒ…å†µä¸‹ä¼šè¿”å›false, æŒ‰ä¸‹Ctrl-Cæ—¶ã€‚æˆ‘ä»¬è¢«ä¸€ä¸ªåŒååŒå§“çš„èŠ‚ç‚¹ä»ç½‘ç»œä¸­è¸¢å‡ºã€‚ros::shutdown()è¢«åº”ç”¨ç¨‹åºçš„å¦ä¸€éƒ¨åˆ†è°ƒç”¨ã€‚æ‰€æœ‰çš„ros::NodeHandleséƒ½è¢«é”€æ¯äº†ã€‚
    while (ros::ok())
    {
        std_msgs::String msg;
        std::stringstream ss;
        ss &amp;lt;&amp;lt; &amp;#34;hello world &amp;#34; &amp;lt;&amp;lt; count;
        msg.data = ss.str();
        ROS_INFO(&amp;#34;%s&amp;#34;, msg.data.c_str());
        /**
         * å‘ Topic: chatter å‘é€æ¶ˆæ¯, å‘é€é¢‘ç‡ä¸º10Hzï¼ˆ1ç§’å‘10æ¬¡ï¼‰ï¼›æ¶ˆæ¯æ± æœ€å¤§å®¹é‡1000ã€‚
         */
        chatter_pub.publish(msg);
        // å¦‚æœè¿è¡Œåˆ°ä¸‹ä¸€æ¬¡loop.sleep()åæœªè¾¾åˆ°è®¾ç½®çš„æ—¶é—´ï¼Œåˆ™ä¼šå¼€å§‹ä¼‘çœ ï¼Œç­‰åˆ°åå†æ‰§è¡Œä¸‹ä¸€å¥
        loop_rate.sleep();
        ++count;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 class=&#34;relative group&#34;&gt;listenerï¼šspin() 
    &lt;div id=&#34;listenerspin&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
    
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#listenerspin&#34; aria-label=&#34;Anchor&#34;&gt;#&lt;/a&gt;
    &lt;/span&gt;        
    
&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;#34;ros/ros.h&amp;#34;
#include &amp;#34;std_msgs/String.h&amp;#34;

// subscriber callback function
void chatterCallback(const std_msgs::String::ConstPtr&amp;amp; msg)
{
    ROS_INFO(&amp;#34;I heard: [%s]&amp;#34;, msg-&amp;gt;data.c_str());
}

int main(int argc, char **argv)
{
    ros::init(argc, argv, &amp;#34;listener&amp;#34;);
    ros::NodeHandle n(&amp;#34;namespace&amp;#34;);
    ros::Subscriber sub = n.subscribe(&amp;#34;chatter&amp;#34;, 1000, chatterCallback);

    /**
     * ros::spin() å°†ä¼šè¿›å…¥å¾ªç¯ï¼Œ ä¸€ç›´è°ƒç”¨å›è°ƒå‡½æ•°chatterCallback(),æ¯æ¬¡è°ƒç”¨1000ä¸ªæ•°æ®ã€‚
     * å½“ç”¨æˆ·è¾“å…¥Ctrl+Cæˆ–è€…ROSä¸»è¿›ç¨‹å…³é—­æ—¶é€€å‡ºï¼Œ
     */
    ros::spin();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 class=&#34;relative group&#34;&gt;listenerï¼šspinOnce() 
    &lt;div id=&#34;listenerspinonce&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
    
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#listenerspinonce&#34; aria-label=&#34;Anchor&#34;&gt;#&lt;/a&gt;
    &lt;/span&gt;        
    
&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;#34;ros/ros.h&amp;#34;
#include &amp;#34;std_msgs/String.h&amp;#34;

// subscriber callback function
void chatterCallback(const std_msgs::String::ConstPtr&amp;amp; msg)
{
    ROS_INFO(&amp;#34;I heard: [%s]&amp;#34;, msg-&amp;gt;data.c_str());
}

int main(int argc, char **argv)
{
    ros::init(argc, argv, &amp;#34;listener&amp;#34;);
    ros::NodeHandle n(&amp;#34;namespace&amp;#34;);
    ros::Subscriber sub = n.subscribe(&amp;#34;chatter&amp;#34;, 1000, chatterCallback);

    ros::Rate loop_rate(5);
    while(ros::ok()){
        ros::spinOnce();
        loop_rate.sleep();
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 class=&#34;relative group&#34;&gt;Ros &amp;amp; OpenCV 
    &lt;div id=&#34;ros--opencv&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
    
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#ros--opencv&#34; aria-label=&#34;Anchor&#34;&gt;#&lt;/a&gt;
    &lt;/span&gt;        
    
&lt;/h1&gt;
&lt;h2 class=&#34;relative group&#34;&gt;ros to opencv 
    &lt;div id=&#34;ros-to-opencv&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
    
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#ros-to-opencv&#34; aria-label=&#34;Anchor&#34;&gt;#&lt;/a&gt;
    &lt;/span&gt;        
    
&lt;/h2&gt;
&lt;p&gt;è¦ç†è§£ï¼Œæ ¸å¿ƒæ˜¯åœ¨opencvã€‚rosåªæ˜¯ä¸€ä¸ªè¾“å…¥çš„å·¥å…·ã€‚&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;ros/ros.h&amp;gt;
// Using image_transport for publishing and subscribing to images in ROS allows you to subscribe to compressed image streams.
#include &amp;lt;image_transport/image_transport.h&amp;gt;
#include &amp;lt;cv_bridge/cv_bridge.h&amp;gt;
// some useful constants and functions related to image encodings.
#include &amp;lt;sensor_msgs/image_encodings.h&amp;gt;
// OpenCV&amp;#39;s image processing and GUI modules.
#include &amp;lt;opencv2/imgproc/imgproc.hpp&amp;gt;
#include &amp;lt;opencv2/highgui/highgui.hpp&amp;gt;

static const std::string OPENCV_WINDOW = &amp;#34;Image window&amp;#34;;

class ImageConverter
{
    ros::NodeHandle nh_;
    // image_transportç±»ï¼šå›¾åƒä¼ è¾“ç±»ï¼Œå…¶åŠŸèƒ½å’ŒROSä¸­çš„Publisherå’ŒSubscriberå·®ä¸å¤šï¼Œä½†æ˜¯ä¸åŒçš„æ˜¯è¿™ä¸ªç±»åœ¨å‘å¸ƒå’Œè®¢é˜…å›¾ç‰‡æ¶ˆæ¯çš„åŒæ—¶è¿˜é™„å¸¦è¿™æ‘„åƒå¤´çš„ä¿¡æ¯ã€‚
    // ç›¸æ¯”è¾ƒä¹‹ä¸‹, åœ¨ROSä¸­ä¼ é€å›¾ç‰‡ä¿¡æ¯ï¼Œä½¿ç”¨image_transportç±»è¦é«˜æ•ˆçš„å¤šã€‚
    image_transport::ImageTransport it_;
    image_transport::Subscriber image_sub_;
    image_transport::Publisher image_pub_;

public:
    ImageConverter()
        : it_(nh_)
    {
        // Subscrive to input video feed and publish output video feed
        image_sub_ = it_.subscribe(&amp;#34;/camera/image_raw&amp;#34;, 1,
                                   &amp;amp;ImageConverter::imageCb, this);
        image_pub_ = it_.advertise(&amp;#34;/image_converter/output_video&amp;#34;, 1);

        // OpenCV HighGUI calls to create/destroy a display window on start-up/shutdown.
        cv::namedWindow(OPENCV_WINDOW);
    }

    ~ImageConverter()
    {
        cv::destroyWindow(OPENCV_WINDOW);
    }

    void imageCb(const sensor_msgs::ImageConstPtr &amp;amp;msg)
    {
        // CvBridge defines a CvImage type containing an OpenCV image, its encoding and a ROS header.
        // ä¸­æ–‡è¯´çš„è¯å°±æ˜¯ï¼š cv_bidge::CvImageç±»ï¼šcv_bridgeä¸­æä¾›çš„æ•°æ®ç»“æ„ï¼Œé‡Œé¢åŒ…æ‹¬OpenCVä¸­çš„cv::Matç±»å‹çš„å›¾åƒä¿¡æ¯ï¼Œå›¾åƒç¼–ç æ–¹å¼ï¼ŒROSå¤´æ–‡ä»¶ç­‰ç­‰ã€‚
        cv_bridge::CvImagePtr cv_ptr;
        try
        {
            // Note that OpenCV expects color images to use BGR channel order.
            cv_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);
        }
        catch (cv_bridge::Exception &amp;amp;e)
        {
            ROS_ERROR(&amp;#34;cv_bridge exception: %s&amp;#34;, e.what());
            return;
        }

        // Draw an example circle on the video stream
        if (cv_ptr-&amp;gt;image.rows &amp;gt; 60 &amp;amp;&amp;amp; cv_ptr-&amp;gt;image.cols &amp;gt; 60)
            cv::circle(cv_ptr-&amp;gt;image, cv::Point(50, 50), 10, CV_RGB(255, 0, 0));

        // Update GUI Window
        cv::imshow(OPENCV_WINDOW, cv_ptr-&amp;gt;image);
        cv::waitKey(3);

        // Output modified video stream
        image_pub_.publish(cv_ptr-&amp;gt;toImageMsg());
    }
};

int main(int argc, char **argv)
{
    ros::init(argc, argv, &amp;#34;image_converter&amp;#34;);
    ImageConverter ic;
    ros::spin();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;å¯¹åº”çš„CMakeListsï¼š&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cmake_minimum_required(VERSION 3.0.2)
project(opencv_study)

find_package(catkin REQUIRED COMPONENTS
  roscpp
  rospy
  sensor_msgs
  cv_bridge
  std_msgs
  image_transport
)

catkin_package(
#  INCLUDE_DIRS include
#  LIBRARIES opencv_study
#  CATKIN_DEPENDS roscpp rospy
#  DEPENDS system_lib
)

include_directories(
# include
  ${catkin_INCLUDE_DIRS}
)

add_executable(image_converter src/image_converter.cpp)
target_link_libraries(image_converter ${catkin_LIBRARIES})
&lt;/code&gt;&lt;/pre&gt;&lt;h2 class=&#34;relative group&#34;&gt;&lt;strong&gt;è¯é¢˜åç§°é‡æ˜ å°„&lt;/strong&gt; 
    &lt;div id=&#34;è¯é¢˜åç§°é‡æ˜ å°„&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
    
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e8%af%9d%e9%a2%98%e5%90%8d%e7%a7%b0%e9%87%8d%e6%98%a0%e5%b0%84&#34; aria-label=&#34;Anchor&#34;&gt;#&lt;/a&gt;
    &lt;/span&gt;        
    
&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;rosrun opencv_study image_converter /camera/image_raw:=/camera/color/image_raw
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;è¿™å¥è¯å°†åŸæ¥è®¢é˜…çš„è¯é¢˜&lt;code&gt;/camera/image_raw&lt;/code&gt;æ”¹åä¸º&lt;code&gt;/camera/color/image_raw&lt;/code&gt;ã€‚&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ros run&lt;/code&gt;Â åé¢çš„å‚æ•°çš„æ„ä¹‰ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__ns:=&lt;/code&gt;Â : æ›´æ”¹èŠ‚ç‚¹çš„å‘½åç©ºé—´&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__name:=&lt;/code&gt;:æ›´æ”¹èŠ‚ç‚¹çš„åç§°&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A:=B&lt;/code&gt;:è¯é¢˜é‡æ˜ å°„ï¼Œ&lt;code&gt;A â†’ B&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class=&#34;relative group&#34;&gt;opencv to tos 
    &lt;div id=&#34;opencv-to-tos&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
    
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#opencv-to-tos&#34; aria-label=&#34;Anchor&#34;&gt;#&lt;/a&gt;
    &lt;/span&gt;        
    
&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;sstream&amp;gt;
using namespace std;

// OpenCV includes
#include &amp;lt;opencv2/video.hpp&amp;gt;
#include &amp;lt;opencv2/opencv.hpp&amp;gt;
#include &amp;lt;opencv2/core/core.hpp&amp;gt;
#include &amp;lt;opencv2/imgproc/imgproc.hpp&amp;gt;
#include &amp;lt;opencv2/calib3d/calib3d.hpp&amp;gt;
#include &amp;lt;opencv2/highgui/highgui.hpp&amp;gt;
#include &amp;#34;opencv2/imgcodecs/legacy/constants_c.h&amp;#34;

using namespace cv;

#include &amp;lt;ros/ros.h&amp;gt;
#include &amp;lt;cv_bridge/cv_bridge.h&amp;gt;
#include &amp;lt;image_transport/image_transport.h&amp;gt;
#include &amp;lt;sensor_msgs/image_encodings.h&amp;gt;

int main(int argc, char **argv)
{
	ros::init(argc, argv, &amp;#34;image_color&amp;#34;);
	ros::NodeHandle nh;
	image_transport::ImageTransport it(nh);
	image_transport::Publisher pub = it.advertise(&amp;#34;/camera_sim/image_raw&amp;#34;, 1);
	/**************ROSä¸Opencvå›¾åƒè½¬æ¢***********************/
	Mat image = imread(&amp;#34;/home/agilex/Desktop/ty/catkin_ws/src/scout_work_1/src/index.jpeg&amp;#34;, CV_LOAD_IMAGE_COLOR);
	sensor_msgs::ImagePtr msg = cv_bridge::CvImage(std_msgs::Header(), &amp;#34;bgr8&amp;#34;, image).toImageMsg();
	ros::Rate loop_rate(5);
	while (nh.ok())
	{
		pub.publish(msg);
		ros::spinOnce();
		loop_rate.sleep();
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
  </channel>
</rss>
